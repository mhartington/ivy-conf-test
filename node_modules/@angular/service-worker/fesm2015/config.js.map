{"version":3,"sources":["/Users/mhartington/GitHub/ionic-conference-app/node_modules/@angular/service-worker/fesm2015/config.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAoBA","file":"config.js","sourcesContent":["/**\n * @license Angular v9.0.0-next.2\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { __awaiter } from 'tslib';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @type {?} */\nconst PARSE_TO_PAIRS = /([0-9]+[^0-9]+)/g;\n/** @type {?} */\nconst PAIR_SPLIT = /^([0-9]+)([dhmsu]+)$/;\n/**\n * @param {?} duration\n * @return {?}\n */\nfunction parseDurationToMs(duration) {\n    /** @type {?} */\n    const matches = [];\n    /** @type {?} */\n    let array;\n    while ((array = PARSE_TO_PAIRS.exec(duration)) !== null) {\n        matches.push(array[0]);\n    }\n    return matches\n        .map((/**\n     * @param {?} match\n     * @return {?}\n     */\n    match => {\n        /** @type {?} */\n        const res = PAIR_SPLIT.exec(match);\n        if (res === null) {\n            throw new Error(`Not a valid duration: ${match}`);\n        }\n        /** @type {?} */\n        let factor = 0;\n        switch (res[2]) {\n            case 'd':\n                factor = 86400000;\n                break;\n            case 'h':\n                factor = 3600000;\n                break;\n            case 'm':\n                factor = 60000;\n                break;\n            case 's':\n                factor = 1000;\n                break;\n            case 'u':\n                factor = 1;\n                break;\n            default:\n                throw new Error(`Not a valid duration unit: ${res[2]}`);\n        }\n        return parseInt(res[1]) * factor;\n    }))\n        .reduce((/**\n     * @param {?} total\n     * @param {?} value\n     * @return {?}\n     */\n    (total, value) => total + value), 0);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @type {?} */\nconst QUESTION_MARK = '[^/]';\n/** @type {?} */\nconst WILD_SINGLE = '[^/]*';\n/** @type {?} */\nconst WILD_OPEN = '(?:.+\\\\/)?';\n/** @type {?} */\nconst TO_ESCAPE_BASE = [\n    { replace: /\\./g, with: '\\\\.' },\n    { replace: /\\+/g, with: '\\\\+' },\n    { replace: /\\*/g, with: WILD_SINGLE },\n];\n/** @type {?} */\nconst TO_ESCAPE_WILDCARD_QM = [\n    ...TO_ESCAPE_BASE,\n    { replace: /\\?/g, with: QUESTION_MARK },\n];\n/** @type {?} */\nconst TO_ESCAPE_LITERAL_QM = [\n    ...TO_ESCAPE_BASE,\n    { replace: /\\?/g, with: '\\\\?' },\n];\n/**\n * @param {?} glob\n * @param {?=} literalQuestionMark\n * @return {?}\n */\nfunction globToRegex(glob, literalQuestionMark = false) {\n    /** @type {?} */\n    const toEscape = literalQuestionMark ? TO_ESCAPE_LITERAL_QM : TO_ESCAPE_WILDCARD_QM;\n    /** @type {?} */\n    const segments = glob.split('/').reverse();\n    /** @type {?} */\n    let regex = '';\n    while (segments.length > 0) {\n        /** @type {?} */\n        const segment = (/** @type {?} */ (segments.pop()));\n        if (segment === '**') {\n            if (segments.length > 0) {\n                regex += WILD_OPEN;\n            }\n            else {\n                regex += '.*';\n            }\n        }\n        else {\n            /** @type {?} */\n            const processed = toEscape.reduce((/**\n             * @param {?} segment\n             * @param {?} escape\n             * @return {?}\n             */\n            (segment, escape) => segment.replace(escape.replace, escape.with)), segment);\n            regex += processed;\n            if (segments.length > 0) {\n                regex += '\\\\/';\n            }\n        }\n    }\n    return regex;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst DEFAULT_NAVIGATION_URLS = [\n    '/**',\n    '!/**/*.*',\n    '!/**/*__*',\n    '!/**/*__*/**',\n];\n/**\n * Consumes service worker configuration files and processes them into control files.\n *\n * \\@publicApi\n */\nclass Generator {\n    /**\n     * @param {?} fs\n     * @param {?} baseHref\n     */\n    constructor(fs, baseHref) {\n        this.fs = fs;\n        this.baseHref = baseHref;\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n    process(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** @type {?} */\n            const unorderedHashTable = {};\n            /** @type {?} */\n            const assetGroups = yield this.processAssetGroups(config, unorderedHashTable);\n            return {\n                configVersion: 1,\n                timestamp: Date.now(),\n                appData: config.appData,\n                index: joinUrls(this.baseHref, config.index), assetGroups,\n                dataGroups: this.processDataGroups(config),\n                hashTable: withOrderedKeys(unorderedHashTable),\n                navigationUrls: processNavigationUrls(this.baseHref, config.navigationUrls),\n            };\n        });\n    }\n    /**\n     * @private\n     * @param {?} config\n     * @param {?} hashTable\n     * @return {?}\n     */\n    processAssetGroups(config, hashTable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** @type {?} */\n            const seenMap = new Set();\n            return Promise.all((config.assetGroups || []).map((/**\n             * @param {?} group\n             * @return {?}\n             */\n            (group) => __awaiter(this, void 0, void 0, function* () {\n                if (group.resources.versionedFiles) {\n                    console.warn(`Asset-group '${group.name}' in 'ngsw-config.json' uses the 'versionedFiles' option.\\n` +\n                        'As of v6 \\'versionedFiles\\' and \\'files\\' options have the same behavior. ' +\n                        'Use \\'files\\' instead.');\n                }\n                /** @type {?} */\n                const fileMatcher = globListToMatcher(group.resources.files || []);\n                /** @type {?} */\n                const versionedMatcher = globListToMatcher(group.resources.versionedFiles || []);\n                /** @type {?} */\n                const allFiles = yield this.fs.list('/');\n                /** @type {?} */\n                const plainFiles = allFiles.filter(fileMatcher).filter((/**\n                 * @param {?} file\n                 * @return {?}\n                 */\n                file => !seenMap.has(file)));\n                plainFiles.forEach((/**\n                 * @param {?} file\n                 * @return {?}\n                 */\n                file => seenMap.add(file)));\n                /** @type {?} */\n                const versionedFiles = allFiles.filter(versionedMatcher).filter((/**\n                 * @param {?} file\n                 * @return {?}\n                 */\n                file => !seenMap.has(file)));\n                versionedFiles.forEach((/**\n                 * @param {?} file\n                 * @return {?}\n                 */\n                file => seenMap.add(file)));\n                // Add the hashes.\n                /** @type {?} */\n                const matchedFiles = [...plainFiles, ...versionedFiles].sort();\n                yield matchedFiles.reduce((/**\n                 * @param {?} previous\n                 * @param {?} file\n                 * @return {?}\n                 */\n                (previous, file) => __awaiter(this, void 0, void 0, function* () {\n                    yield previous;\n                    /** @type {?} */\n                    const hash = yield this.fs.hash(file);\n                    hashTable[joinUrls(this.baseHref, file)] = hash;\n                })), Promise.resolve());\n                return {\n                    name: group.name,\n                    installMode: group.installMode || 'prefetch',\n                    updateMode: group.updateMode || group.installMode || 'prefetch',\n                    urls: matchedFiles.map((/**\n                     * @param {?} url\n                     * @return {?}\n                     */\n                    url => joinUrls(this.baseHref, url))),\n                    patterns: (group.resources.urls || []).map((/**\n                     * @param {?} url\n                     * @return {?}\n                     */\n                    url => urlToRegex(url, this.baseHref, true))),\n                };\n            }))));\n        });\n    }\n    /**\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    processDataGroups(config) {\n        return (config.dataGroups || []).map((/**\n         * @param {?} group\n         * @return {?}\n         */\n        group => {\n            return {\n                name: group.name,\n                patterns: group.urls.map((/**\n                 * @param {?} url\n                 * @return {?}\n                 */\n                url => urlToRegex(url, this.baseHref, true))),\n                strategy: group.cacheConfig.strategy || 'performance',\n                maxSize: group.cacheConfig.maxSize,\n                maxAge: parseDurationToMs(group.cacheConfig.maxAge),\n                timeoutMs: group.cacheConfig.timeout && parseDurationToMs(group.cacheConfig.timeout),\n                version: group.version !== undefined ? group.version : 1,\n            };\n        }));\n    }\n}\nif (false) {\n    /** @type {?} */\n    Generator.prototype.fs;\n    /**\n     * @type {?}\n     * @private\n     */\n    Generator.prototype.baseHref;\n}\n/**\n * @param {?} baseHref\n * @param {?=} urls\n * @return {?}\n */\nfunction processNavigationUrls(baseHref, urls = DEFAULT_NAVIGATION_URLS) {\n    return urls.map((/**\n     * @param {?} url\n     * @return {?}\n     */\n    url => {\n        /** @type {?} */\n        const positive = !url.startsWith('!');\n        url = positive ? url : url.substr(1);\n        return { positive, regex: `^${urlToRegex(url, baseHref)}$` };\n    }));\n}\n/**\n * @param {?} globs\n * @return {?}\n */\nfunction globListToMatcher(globs) {\n    /** @type {?} */\n    const patterns = globs.map((/**\n     * @param {?} pattern\n     * @return {?}\n     */\n    pattern => {\n        if (pattern.startsWith('!')) {\n            return {\n                positive: false,\n                regex: new RegExp('^' + globToRegex(pattern.substr(1)) + '$'),\n            };\n        }\n        else {\n            return {\n                positive: true,\n                regex: new RegExp('^' + globToRegex(pattern) + '$'),\n            };\n        }\n    }));\n    return (/**\n     * @param {?} file\n     * @return {?}\n     */\n    (file) => matches(file, patterns));\n}\n/**\n * @param {?} file\n * @param {?} patterns\n * @return {?}\n */\nfunction matches(file, patterns) {\n    /** @type {?} */\n    const res = patterns.reduce((/**\n     * @param {?} isMatch\n     * @param {?} pattern\n     * @return {?}\n     */\n    (isMatch, pattern) => {\n        if (pattern.positive) {\n            return isMatch || pattern.regex.test(file);\n        }\n        else {\n            return isMatch && !pattern.regex.test(file);\n        }\n    }), false);\n    return res;\n}\n/**\n * @param {?} url\n * @param {?} baseHref\n * @param {?=} literalQuestionMark\n * @return {?}\n */\nfunction urlToRegex(url, baseHref, literalQuestionMark) {\n    if (!url.startsWith('/') && url.indexOf('://') === -1) {\n        url = joinUrls(baseHref, url);\n    }\n    return globToRegex(url, literalQuestionMark);\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction joinUrls(a, b) {\n    if (a.endsWith('/') && b.startsWith('/')) {\n        return a + b.substr(1);\n    }\n    else if (!a.endsWith('/') && !b.startsWith('/')) {\n        return a + '/' + b;\n    }\n    return a + b;\n}\n/**\n * @template T\n * @param {?} unorderedObj\n * @return {?}\n */\nfunction withOrderedKeys(unorderedObj) {\n    /** @type {?} */\n    const orderedObj = (/** @type {?} */ ({}));\n    Object.keys(unorderedObj).sort().forEach((/**\n     * @param {?} key\n     * @return {?}\n     */\n    key => orderedObj[key] = unorderedObj[key]));\n    return (/** @type {?} */ (orderedObj));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Generator };\n"]}