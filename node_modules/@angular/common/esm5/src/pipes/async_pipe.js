/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { ChangeDetectorRef, Injectable, Pipe, WrappedValue, ɵisObservable, ɵisPromise, ɵlooseIdentical } from '@angular/core';
import { invalidPipeArgumentError } from './invalid_pipe_argument_error';
import * as ɵngcc0 from '@angular/core';
var ObservableStrategy = /** @class */ (function () {
    function ObservableStrategy() {
    }
    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
    };
    ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
    ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
    return ObservableStrategy;
}());
var PromiseStrategy = /** @class */ (function () {
    function PromiseStrategy() {
    }
    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.then(updateLatestValue, function (e) { throw e; });
    };
    PromiseStrategy.prototype.dispose = function (subscription) { };
    PromiseStrategy.prototype.onDestroy = function (subscription) { };
    return PromiseStrategy;
}());
var _promiseStrategy = new PromiseStrategy();
var _observableStrategy = new ObservableStrategy();
/**
 * @ngModule CommonModule
 * @description
 *
 * Unwraps a value from an asynchronous primitive.
 *
 * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
 * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
 * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
 * potential memory leaks.
 *
 * @usageNotes
 *
 * ### Examples
 *
 * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
 * promise.
 *
 * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
 *
 * It's also possible to use `async` with Observables. The example below binds the `time` Observable
 * to the view. The Observable continuously updates the view with the current time.
 *
 * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
 *
 * @publicApi
 */
var AsyncPipe = /** @class */ (function () {
    function AsyncPipe(_ref) {
        this._ref = _ref;
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
        this._strategy = null;
    }
    AsyncPipe_1 = AsyncPipe;
    AsyncPipe.prototype.ngOnDestroy = function () {
        if (this._subscription) {
            this._dispose();
        }
    };
    AsyncPipe.prototype.transform = function (obj) {
        if (!this._obj) {
            if (obj) {
                this._subscribe(obj);
            }
            this._latestReturnedValue = this._latestValue;
            return this._latestValue;
        }
        if (obj !== this._obj) {
            this._dispose();
            return this.transform(obj);
        }
        if (ɵlooseIdentical(this._latestValue, this._latestReturnedValue)) {
            return this._latestReturnedValue;
        }
        this._latestReturnedValue = this._latestValue;
        return WrappedValue.wrap(this._latestValue);
    };
    AsyncPipe.prototype._subscribe = function (obj) {
        var _this = this;
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
    };
    AsyncPipe.prototype._selectStrategy = function (obj) {
        if (ɵisPromise(obj)) {
            return _promiseStrategy;
        }
        if (ɵisObservable(obj)) {
            return _observableStrategy;
        }
        throw invalidPipeArgumentError(AsyncPipe_1, obj);
    };
    AsyncPipe.prototype._dispose = function () {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
    };
    AsyncPipe.prototype._updateLatestValue = function (async, value) {
        if (async === this._obj) {
            this._latestValue = value;
            this._ref.markForCheck();
        }
    };
    var AsyncPipe_1;
    AsyncPipe = AsyncPipe_1 = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [ChangeDetectorRef])
    ], AsyncPipe);
AsyncPipe.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: AsyncPipe, factory: function AsyncPipe_Factory(t) { return new (t || AsyncPipe)(ɵngcc0.ɵɵinject(ChangeDetectorRef)); }, providedIn: null });
AsyncPipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "async", type: AsyncPipe, factory: function AsyncPipe_Factory(t) { return new (t || AsyncPipe)(ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef)); }, pure: false });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AsyncPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'async', pure: false }]
    }], function () { return [{ type: ChangeDetectorRef }]; }, { _ref: [], _latestValue: [], _latestReturnedValue: [], _subscription: [], _obj: [], _strategy: [], ngOnDestroy: [], transform: [], _subscribe: [], _selectStrategy: [], _dispose: [], _updateLatestValue: [] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(AsyncPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{ name: 'async', pure: false }]
    }], function () { return [{ type: ChangeDetectorRef }]; }, { _ref: [], _latestValue: [], _latestReturnedValue: [], _subscription: [], _obj: [], _strategy: [], ngOnDestroy: [], transform: [], _subscribe: [], _selectStrategy: [], _dispose: [], _updateLatestValue: [] });
    return AsyncPipe;
}());
export { AsyncPipe };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9taGFydGluZ3Rvbi9HaXRIdWIvaW9uaWMtY29uZmVyZW5jZS1hcHAvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9lc201L3NyYy9waXBlcy9hc3luY19waXBlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBK0drRCxBQUVMOzs7Ozs7Ozs7Ozs7Ozs7O2dSQUUzQiIsImZpbGUiOiJhc3luY19waXBlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBJbmplY3RhYmxlLCBQaXBlLCBXcmFwcGVkVmFsdWUsIMm1aXNPYnNlcnZhYmxlLCDJtWlzUHJvbWlzZSwgybVsb29zZUlkZW50aWNhbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaW52YWxpZFBpcGVBcmd1bWVudEVycm9yIH0gZnJvbSAnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXJyb3InO1xudmFyIE9ic2VydmFibGVTdHJhdGVneSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlU3RyYXRlZ3koKSB7XG4gICAgfVxuICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYXN5bmMuc3Vic2NyaWJlKHsgbmV4dDogdXBkYXRlTGF0ZXN0VmFsdWUsIGVycm9yOiBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9IH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVTdHJhdGVneTtcbn0oKSk7XG52YXIgUHJvbWlzZVN0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb21pc2VTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhc3luYy50aGVuKHVwZGF0ZUxhdGVzdFZhbHVlLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KTtcbiAgICB9O1xuICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcbiAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcbiAgICByZXR1cm4gUHJvbWlzZVN0cmF0ZWd5O1xufSgpKTtcbnZhciBfcHJvbWlzZVN0cmF0ZWd5ID0gbmV3IFByb21pc2VTdHJhdGVneSgpO1xudmFyIF9vYnNlcnZhYmxlU3RyYXRlZ3kgPSBuZXcgT2JzZXJ2YWJsZVN0cmF0ZWd5KCk7XG4vKipcbiAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFVud3JhcHMgYSB2YWx1ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBwcmltaXRpdmUuXG4gKlxuICogVGhlIGBhc3luY2AgcGlwZSBzdWJzY3JpYmVzIHRvIGFuIGBPYnNlcnZhYmxlYCBvciBgUHJvbWlzZWAgYW5kIHJldHVybnMgdGhlIGxhdGVzdCB2YWx1ZSBpdCBoYXNcbiAqIGVtaXR0ZWQuIFdoZW4gYSBuZXcgdmFsdWUgaXMgZW1pdHRlZCwgdGhlIGBhc3luY2AgcGlwZSBtYXJrcyB0aGUgY29tcG9uZW50IHRvIGJlIGNoZWNrZWQgZm9yXG4gKiBjaGFuZ2VzLiBXaGVuIHRoZSBjb21wb25lbnQgZ2V0cyBkZXN0cm95ZWQsIHRoZSBgYXN5bmNgIHBpcGUgdW5zdWJzY3JpYmVzIGF1dG9tYXRpY2FsbHkgdG8gYXZvaWRcbiAqIHBvdGVudGlhbCBtZW1vcnkgbGVha3MuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgRXhhbXBsZXNcbiAqXG4gKiBUaGlzIGV4YW1wbGUgYmluZHMgYSBgUHJvbWlzZWAgdG8gdGhlIHZpZXcuIENsaWNraW5nIHRoZSBgUmVzb2x2ZWAgYnV0dG9uIHJlc29sdmVzIHRoZVxuICogcHJvbWlzZS5cbiAqXG4gKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2FzeW5jX3BpcGUudHMgcmVnaW9uPSdBc3luY1BpcGVQcm9taXNlJ31cbiAqXG4gKiBJdCdzIGFsc28gcG9zc2libGUgdG8gdXNlIGBhc3luY2Agd2l0aCBPYnNlcnZhYmxlcy4gVGhlIGV4YW1wbGUgYmVsb3cgYmluZHMgdGhlIGB0aW1lYCBPYnNlcnZhYmxlXG4gKiB0byB0aGUgdmlldy4gVGhlIE9ic2VydmFibGUgY29udGludW91c2x5IHVwZGF0ZXMgdGhlIHZpZXcgd2l0aCB0aGUgY3VycmVudCB0aW1lLlxuICpcbiAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvYXN5bmNfcGlwZS50cyByZWdpb249J0FzeW5jUGlwZU9ic2VydmFibGUnfVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xudmFyIEFzeW5jUGlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY1BpcGUoX3JlZikge1xuICAgICAgICB0aGlzLl9yZWYgPSBfcmVmO1xuICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9vYmogPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG51bGw7XG4gICAgfVxuICAgIEFzeW5jUGlwZV8xID0gQXN5bmNQaXBlO1xuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiAhPT0gdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoybVsb29zZUlkZW50aWNhbCh0aGlzLl9sYXRlc3RWYWx1ZSwgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcbiAgICAgICAgcmV0dXJuIFdyYXBwZWRWYWx1ZS53cmFwKHRoaXMuX2xhdGVzdFZhbHVlKTtcbiAgICB9O1xuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IHRoaXMuX3NlbGVjdFN0cmF0ZWd5KG9iaik7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3N0cmF0ZWd5LmNyZWF0ZVN1YnNjcmlwdGlvbihvYmosIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZUxhdGVzdFZhbHVlKG9iaiwgdmFsdWUpOyB9KTtcbiAgICB9O1xuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3NlbGVjdFN0cmF0ZWd5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoybVpc1Byb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlU3RyYXRlZ3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKMm1aXNPYnNlcnZhYmxlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2YWJsZVN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGludmFsaWRQaXBlQXJndW1lbnRFcnJvcihBc3luY1BpcGVfMSwgb2JqKTtcbiAgICB9O1xuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5LmRpc3Bvc2UodGhpcy5fc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcbiAgICB9O1xuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3VwZGF0ZUxhdGVzdFZhbHVlID0gZnVuY3Rpb24gKGFzeW5jLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXN5bmMgPT09IHRoaXMuX29iaikge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIEFzeW5jUGlwZV8xO1xuICAgIEFzeW5jUGlwZSA9IEFzeW5jUGlwZV8xID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICBQaXBlKHsgbmFtZTogJ2FzeW5jJywgcHVyZTogZmFsc2UgfSksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDaGFuZ2VEZXRlY3RvclJlZl0pXG4gICAgXSwgQXN5bmNQaXBlKTtcbiAgICByZXR1cm4gQXN5bmNQaXBlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jUGlwZSB9O1xuIl19