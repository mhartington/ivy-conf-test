import * as tslib_1 from "tslib";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ElementRef, Injectable, IterableDiffers, KeyValueDiffers, Renderer2, ɵisListLikeIterable as isListLikeIterable, ɵstringify as stringify } from '@angular/core';
import { StylingDiffer } from './styling_differ';
/**
 * Used as a token for an injected service within the NgClass directive.
 *
 * NgClass behaves differenly whether or not VE is being used or not. If
 * present then the legacy ngClass diffing algorithm will be used as an
 * injected service. Otherwise the new diffing algorithm (which delegates
 * to the `[class]` binding) will be used. This toggle behavior is done so
 * via the ivy_switch mechanism.
 */
import * as ɵngcc0 from '@angular/core';
var NgClassImpl = /** @class */ (function () {
    function NgClassImpl() {
    }
    return NgClassImpl;
}());
export { NgClassImpl };
var NgClassR2Impl = /** @class */ (function () {
    function NgClassR2Impl(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
    }
    NgClassR2Impl.prototype.getValue = function () { return null; };
    NgClassR2Impl.prototype.setClass = function (value) {
        this._removeClasses(this._initialClasses);
        this._initialClasses = typeof value === 'string' ? value.split(/\s+/) : [];
        this._applyClasses(this._initialClasses);
        this._applyClasses(this._rawClass);
    };
    NgClassR2Impl.prototype.setNgClass = function (value) {
        this._removeClasses(this._rawClass);
        this._applyClasses(this._initialClasses);
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        this._rawClass = typeof value === 'string' ? value.split(/\s+/) : value;
        if (this._rawClass) {
            if (isListLikeIterable(this._rawClass)) {
                this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
            }
            else {
                this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
            }
        }
    };
    NgClassR2Impl.prototype.applyChanges = function () {
        if (this._iterableDiffer) {
            var iterableChanges = this._iterableDiffer.diff(this._rawClass);
            if (iterableChanges) {
                this._applyIterableChanges(iterableChanges);
            }
        }
        else if (this._keyValueDiffer) {
            var keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
            if (keyValueChanges) {
                this._applyKeyValueChanges(keyValueChanges);
            }
        }
    };
    NgClassR2Impl.prototype._applyKeyValueChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) {
            if (record.previousValue) {
                _this._toggleClass(record.key, false);
            }
        });
    };
    NgClassR2Impl.prototype._applyIterableChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) {
            if (typeof record.item === 'string') {
                _this._toggleClass(record.item, true);
            }
            else {
                throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + stringify(record.item));
            }
        });
        changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
    };
    /**
     * Applies a collection of CSS classes to the DOM element.
     *
     * For argument of type Set and Array CSS class names contained in those collections are always
     * added.
     * For argument of type Map CSS class name in the map's key is toggled based on the value (added
     * for truthy and removed for falsy).
     */
    NgClassR2Impl.prototype._applyClasses = function (rawClassVal) {
        var _this = this;
        if (rawClassVal) {
            if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, true); });
            }
            else {
                Object.keys(rawClassVal).forEach(function (klass) { return _this._toggleClass(klass, !!rawClassVal[klass]); });
            }
        }
    };
    /**
     * Removes a collection of CSS classes from the DOM element. This is mostly useful for cleanup
     * purposes.
     */
    NgClassR2Impl.prototype._removeClasses = function (rawClassVal) {
        var _this = this;
        if (rawClassVal) {
            if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, false); });
            }
            else {
                Object.keys(rawClassVal).forEach(function (klass) { return _this._toggleClass(klass, false); });
            }
        }
    };
    NgClassR2Impl.prototype._toggleClass = function (klass, enabled) {
        var _this = this;
        klass = klass.trim();
        if (klass) {
            klass.split(/\s+/g).forEach(function (klass) {
                if (enabled) {
                    _this._renderer.addClass(_this._ngEl.nativeElement, klass);
                }
                else {
                    _this._renderer.removeClass(_this._ngEl.nativeElement, klass);
                }
            });
        }
    };
    NgClassR2Impl = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [IterableDiffers, KeyValueDiffers,
            ElementRef, Renderer2])
    ], NgClassR2Impl);
NgClassR2Impl.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgClassR2Impl, factory: function NgClassR2Impl_Factory(t) { return new (t || NgClassR2Impl)(ɵngcc0.ɵɵinject(IterableDiffers), ɵngcc0.ɵɵinject(KeyValueDiffers), ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(Renderer2)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgClassR2Impl, [{
        type: Injectable
    }], function () { return [{ type: IterableDiffers }, { type: KeyValueDiffers }, { type: ElementRef }, { type: Renderer2 }]; }, { _iterableDiffers: [], _keyValueDiffers: [], _ngEl: [], _renderer: [], _initialClasses: [], getValue: [], setClass: [], setNgClass: [], _iterableDiffer: [], _keyValueDiffer: [], _rawClass: [], applyChanges: [], _applyKeyValueChanges: [], _applyIterableChanges: [], _applyClasses: [], _removeClasses: [], _toggleClass: [] });
    return NgClassR2Impl;
}());
export { NgClassR2Impl };
var NgClassR3Impl = /** @class */ (function () {
    function NgClassR3Impl() {
        this._value = null;
        this._ngClassDiffer = new StylingDiffer('NgClass', 1 /* TrimProperties */ |
            2 /* AllowSubKeys */ |
            4 /* AllowStringValue */ | 16 /* ForceAsMap */);
        this._classStringDiffer = null;
    }
    NgClassR3Impl.prototype.getValue = function () { return this._value; };
    NgClassR3Impl.prototype.setClass = function (value) {
        // early exit incase the binding gets emitted as an empty value which
        // means there is no reason to instantiate and diff the values...
        if (!value && !this._classStringDiffer)
            return;
        this._classStringDiffer = this._classStringDiffer ||
            new StylingDiffer('class', 4 /* AllowStringValue */ | 16 /* ForceAsMap */);
        this._classStringDiffer.setValue(value);
    };
    NgClassR3Impl.prototype.setNgClass = function (value) {
        this._ngClassDiffer.setValue(value);
    };
    NgClassR3Impl.prototype.applyChanges = function () {
        var classChanged = this._classStringDiffer ? this._classStringDiffer.hasValueChanged() : false;
        var ngClassChanged = this._ngClassDiffer.hasValueChanged();
        if (classChanged || ngClassChanged) {
            var value = this._ngClassDiffer.value;
            if (this._classStringDiffer) {
                var classValue = this._classStringDiffer.value;
                if (classValue) {
                    value = value ? tslib_1.__assign({}, classValue, value) : classValue;
                }
            }
            this._value = value;
        }
    };
NgClassR3Impl.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgClassR3Impl, factory: function NgClassR3Impl_Factory(t) { return new (t || NgClassR3Impl)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgClassR3Impl, [{
        type: Injectable
    }], function () { return []; }, { _value: [], _ngClassDiffer: [], _classStringDiffer: [], getValue: [], setClass: [], setNgClass: [], applyChanges: [] });
    return NgClassR3Impl;
}());
export { NgClassR3Impl };
// the implementation for both NgStyleR2Impl and NgStyleR3Impl are
// not ivy_switch'd away, instead they are only hooked up into the
// DI via NgStyle's directive's provider property.
export var NgClassImplProvider__PRE_R3__ = {
    provide: NgClassImpl,
    useClass: NgClassR2Impl
};
export var NgClassImplProvider__POST_R3__ = {
    provide: NgClassImpl,
    useClass: NgClassR3Impl
};
export var NgClassImplProvider = NgClassImplProvider__POST_R3__;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9taGFydGluZ3Rvbi9HaXRIdWIvaW9uaWMtY29uZmVyZW5jZS1hcHAvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9lc201L3NyYy9kaXJlY3RpdmVzL25nX2NsYXNzX2ltcGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBd0h3QyxBQUNuQjs7Ozs7Ozt3Y0FHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFzQ2hCOzs7OzhKQUdnQjs7Ozs7Ozs7Ozs7Ozs7O2lDQWVXLDhCQUE2QiIsImZpbGUiOiJuZ19jbGFzc19pbXBsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUsIEl0ZXJhYmxlRGlmZmVycywgS2V5VmFsdWVEaWZmZXJzLCBSZW5kZXJlcjIsIMm1aXNMaXN0TGlrZUl0ZXJhYmxlIGFzIGlzTGlzdExpa2VJdGVyYWJsZSwgybVzdHJpbmdpZnkgYXMgc3RyaW5naWZ5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdHlsaW5nRGlmZmVyIH0gZnJvbSAnLi9zdHlsaW5nX2RpZmZlcic7XG4vKipcbiAqIFVzZWQgYXMgYSB0b2tlbiBmb3IgYW4gaW5qZWN0ZWQgc2VydmljZSB3aXRoaW4gdGhlIE5nQ2xhc3MgZGlyZWN0aXZlLlxuICpcbiAqIE5nQ2xhc3MgYmVoYXZlcyBkaWZmZXJlbmx5IHdoZXRoZXIgb3Igbm90IFZFIGlzIGJlaW5nIHVzZWQgb3Igbm90LiBJZlxuICogcHJlc2VudCB0aGVuIHRoZSBsZWdhY3kgbmdDbGFzcyBkaWZmaW5nIGFsZ29yaXRobSB3aWxsIGJlIHVzZWQgYXMgYW5cbiAqIGluamVjdGVkIHNlcnZpY2UuIE90aGVyd2lzZSB0aGUgbmV3IGRpZmZpbmcgYWxnb3JpdGhtICh3aGljaCBkZWxlZ2F0ZXNcbiAqIHRvIHRoZSBgW2NsYXNzXWAgYmluZGluZykgd2lsbCBiZSB1c2VkLiBUaGlzIHRvZ2dsZSBiZWhhdmlvciBpcyBkb25lIHNvXG4gKiB2aWEgdGhlIGl2eV9zd2l0Y2ggbWVjaGFuaXNtLlxuICovXG52YXIgTmdDbGFzc0ltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdDbGFzc0ltcGwoKSB7XG4gICAgfVxuICAgIHJldHVybiBOZ0NsYXNzSW1wbDtcbn0oKSk7XG5leHBvcnQgeyBOZ0NsYXNzSW1wbCB9O1xudmFyIE5nQ2xhc3NSMkltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdDbGFzc1IySW1wbChfaXRlcmFibGVEaWZmZXJzLCBfa2V5VmFsdWVEaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVycyA9IF9pdGVyYWJsZURpZmZlcnM7XG4gICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVycyA9IF9rZXlWYWx1ZURpZmZlcnM7XG4gICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gW107XG4gICAgfVxuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBOZ0NsYXNzUjJJbXBsLnByb3RvdHlwZS5zZXRDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVDbGFzc2VzKHRoaXMuX2luaXRpYWxDbGFzc2VzKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXModGhpcy5faW5pdGlhbENsYXNzZXMpO1xuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXModGhpcy5fcmF3Q2xhc3MpO1xuICAgIH07XG4gICAgTmdDbGFzc1IySW1wbC5wcm90b3R5cGUuc2V0TmdDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzKTtcbiAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHRoaXMuX2luaXRpYWxDbGFzc2VzKTtcbiAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Jhd0NsYXNzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnNwbGl0KC9cXHMrLykgOiB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3Jhd0NsYXNzKSB7XG4gICAgICAgICAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlKHRoaXMuX3Jhd0NsYXNzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gdGhpcy5faXRlcmFibGVEaWZmZXJzLmZpbmQodGhpcy5fcmF3Q2xhc3MpLmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXIgPSB0aGlzLl9rZXlWYWx1ZURpZmZlcnMuZmluZCh0aGlzLl9yYXdDbGFzcykuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLmFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZXJhYmxlRGlmZmVyKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGVDaGFuZ2VzID0gdGhpcy5faXRlcmFibGVEaWZmZXIuZGlmZih0aGlzLl9yYXdDbGFzcyk7XG4gICAgICAgICAgICBpZiAoaXRlcmFibGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJdGVyYWJsZUNoYW5nZXMoaXRlcmFibGVDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9rZXlWYWx1ZURpZmZlcikge1xuICAgICAgICAgICAgdmFyIGtleVZhbHVlQ2hhbmdlcyA9IHRoaXMuX2tleVZhbHVlRGlmZmVyLmRpZmYodGhpcy5fcmF3Q2xhc3MpO1xuICAgICAgICAgICAgaWYgKGtleVZhbHVlQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzKGtleVZhbHVlQ2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLl9hcHBseUtleVZhbHVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5nQ2xhc3NSMkltcGwucHJvdG90eXBlLl9hcHBseUl0ZXJhYmxlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlY29yZC5pdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQuaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZ0NsYXNzIGNhbiBvbmx5IHRvZ2dsZSBDU1MgY2xhc3NlcyBleHByZXNzZWQgYXMgc3RyaW5ncywgZ290IFwiICsgc3RyaW5naWZ5KHJlY29yZC5pdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIGZhbHNlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgY29sbGVjdGlvbiBvZiBDU1MgY2xhc3NlcyB0byB0aGUgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBGb3IgYXJndW1lbnQgb2YgdHlwZSBTZXQgYW5kIEFycmF5IENTUyBjbGFzcyBuYW1lcyBjb250YWluZWQgaW4gdGhvc2UgY29sbGVjdGlvbnMgYXJlIGFsd2F5c1xuICAgICAqIGFkZGVkLlxuICAgICAqIEZvciBhcmd1bWVudCBvZiB0eXBlIE1hcCBDU1MgY2xhc3MgbmFtZSBpbiB0aGUgbWFwJ3Mga2V5IGlzIHRvZ2dsZWQgYmFzZWQgb24gdGhlIHZhbHVlIChhZGRlZFxuICAgICAqIGZvciB0cnV0aHkgYW5kIHJlbW92ZWQgZm9yIGZhbHN5KS5cbiAgICAgKi9cbiAgICBOZ0NsYXNzUjJJbXBsLnByb3RvdHlwZS5fYXBwbHlDbGFzc2VzID0gZnVuY3Rpb24gKHJhd0NsYXNzVmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChyYXdDbGFzc1ZhbCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3Q2xhc3NWYWwpIHx8IHJhd0NsYXNzVmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmF3Q2xhc3NWYWwuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgdHJ1ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3Q2xhc3NWYWwpLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICEhcmF3Q2xhc3NWYWxba2xhc3NdKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aW9uIG9mIENTUyBjbGFzc2VzIGZyb20gdGhlIERPTSBlbGVtZW50LiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yIGNsZWFudXBcbiAgICAgKiBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgICBOZ0NsYXNzUjJJbXBsLnByb3RvdHlwZS5fcmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocmF3Q2xhc3NWYWwpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0NsYXNzVmFsKSB8fCByYXdDbGFzc1ZhbCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJhd0NsYXNzVmFsLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsIGZhbHNlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyYXdDbGFzc1ZhbCkuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTmdDbGFzc1IySW1wbC5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGtsYXNzLCBlbmFibGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGtsYXNzID0ga2xhc3MudHJpbSgpO1xuICAgICAgICBpZiAoa2xhc3MpIHtcbiAgICAgICAgICAgIGtsYXNzLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLmFkZENsYXNzKF90aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIGtsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhfdGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBrbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nQ2xhc3NSMkltcGwgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycyxcbiAgICAgICAgICAgIEVsZW1lbnRSZWYsIFJlbmRlcmVyMl0pXG4gICAgXSwgTmdDbGFzc1IySW1wbCk7XG4gICAgcmV0dXJuIE5nQ2xhc3NSMkltcGw7XG59KCkpO1xuZXhwb3J0IHsgTmdDbGFzc1IySW1wbCB9O1xudmFyIE5nQ2xhc3NSM0ltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdDbGFzc1IzSW1wbCgpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZ0NsYXNzRGlmZmVyID0gbmV3IFN0eWxpbmdEaWZmZXIoJ05nQ2xhc3MnLCAxIC8qIFRyaW1Qcm9wZXJ0aWVzICovIHxcbiAgICAgICAgICAgIDIgLyogQWxsb3dTdWJLZXlzICovIHxcbiAgICAgICAgICAgIDQgLyogQWxsb3dTdHJpbmdWYWx1ZSAqLyB8IDE2IC8qIEZvcmNlQXNNYXAgKi8pO1xuICAgICAgICB0aGlzLl9jbGFzc1N0cmluZ0RpZmZlciA9IG51bGw7XG4gICAgfVxuICAgIE5nQ2xhc3NSM0ltcGwucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH07XG4gICAgTmdDbGFzc1IzSW1wbC5wcm90b3R5cGUuc2V0Q2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gZWFybHkgZXhpdCBpbmNhc2UgdGhlIGJpbmRpbmcgZ2V0cyBlbWl0dGVkIGFzIGFuIGVtcHR5IHZhbHVlIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZXJlIGlzIG5vIHJlYXNvbiB0byBpbnN0YW50aWF0ZSBhbmQgZGlmZiB0aGUgdmFsdWVzLi4uXG4gICAgICAgIGlmICghdmFsdWUgJiYgIXRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9jbGFzc1N0cmluZ0RpZmZlciA9IHRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyIHx8XG4gICAgICAgICAgICBuZXcgU3R5bGluZ0RpZmZlcignY2xhc3MnLCA0IC8qIEFsbG93U3RyaW5nVmFsdWUgKi8gfCAxNiAvKiBGb3JjZUFzTWFwICovKTtcbiAgICAgICAgdGhpcy5fY2xhc3NTdHJpbmdEaWZmZXIuc2V0VmFsdWUodmFsdWUpO1xuICAgIH07XG4gICAgTmdDbGFzc1IzSW1wbC5wcm90b3R5cGUuc2V0TmdDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9uZ0NsYXNzRGlmZmVyLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9O1xuICAgIE5nQ2xhc3NSM0ltcGwucHJvdG90eXBlLmFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsYXNzQ2hhbmdlZCA9IHRoaXMuX2NsYXNzU3RyaW5nRGlmZmVyID8gdGhpcy5fY2xhc3NTdHJpbmdEaWZmZXIuaGFzVmFsdWVDaGFuZ2VkKCkgOiBmYWxzZTtcbiAgICAgICAgdmFyIG5nQ2xhc3NDaGFuZ2VkID0gdGhpcy5fbmdDbGFzc0RpZmZlci5oYXNWYWx1ZUNoYW5nZWQoKTtcbiAgICAgICAgaWYgKGNsYXNzQ2hhbmdlZCB8fCBuZ0NsYXNzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fbmdDbGFzc0RpZmZlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGFzc1N0cmluZ0RpZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc1ZhbHVlID0gdGhpcy5fY2xhc3NTdHJpbmdEaWZmZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IHRzbGliXzEuX19hc3NpZ24oe30sIGNsYXNzVmFsdWUsIHZhbHVlKSA6IGNsYXNzVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTmdDbGFzc1IzSW1wbCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKVxuICAgIF0sIE5nQ2xhc3NSM0ltcGwpO1xuICAgIHJldHVybiBOZ0NsYXNzUjNJbXBsO1xufSgpKTtcbmV4cG9ydCB7IE5nQ2xhc3NSM0ltcGwgfTtcbi8vIHRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgYm90aCBOZ1N0eWxlUjJJbXBsIGFuZCBOZ1N0eWxlUjNJbXBsIGFyZVxuLy8gbm90IGl2eV9zd2l0Y2gnZCBhd2F5LCBpbnN0ZWFkIHRoZXkgYXJlIG9ubHkgaG9va2VkIHVwIGludG8gdGhlXG4vLyBESSB2aWEgTmdTdHlsZSdzIGRpcmVjdGl2ZSdzIHByb3ZpZGVyIHByb3BlcnR5LlxuZXhwb3J0IHZhciBOZ0NsYXNzSW1wbFByb3ZpZGVyX19QUkVfUjNfXyA9IHtcbiAgICBwcm92aWRlOiBOZ0NsYXNzSW1wbCxcbiAgICB1c2VDbGFzczogTmdDbGFzc1IySW1wbFxufTtcbmV4cG9ydCB2YXIgTmdDbGFzc0ltcGxQcm92aWRlcl9fUE9TVF9SM19fID0ge1xuICAgIHByb3ZpZGU6IE5nQ2xhc3NJbXBsLFxuICAgIHVzZUNsYXNzOiBOZ0NsYXNzUjNJbXBsXG59O1xuZXhwb3J0IHZhciBOZ0NsYXNzSW1wbFByb3ZpZGVyID0gTmdDbGFzc0ltcGxQcm92aWRlcl9fUFJFX1IzX187XG4iXX0=